import {query as $query, update as $update, Record, StableBTreeMap, Vec, Result, nat64, ic, Opt, Principal } from 'azle';
import { v4 as uuidv4 } from 'uuid';

const match = <T, U>(value: T | undefined, patterns: { Some: (value: T) => U, None: () => U }): U => {
    if (value !== undefined) {
        return patterns.Some(value);
    } else {
        return patterns.None();
    }
};
type Land = Record<{
    landId: string;
    location: string;
    owner: Principal;
    uniqueIdentifier: string;
    createdAt: nat64;
    updatedAt: Opt<nat64>;
}>

type LandPayload = Record<{
    location: string;
    uniqueIdentifier: string;
}>

type Transaction = Record<{
    transactionId: string;
    landId: string;
    fromOwner: Principal;
    toOwner: Principal;
    createdAt: nat64;
}>;

const landStorage = new StableBTreeMap<string, Land>(0, 44, 1024);
const transactionStorage = new StableBTreeMap<string, Transaction>(1, 44, 1024);


// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
    return str.trim().length == 0
}

function validateLandPayload(payload: LandPayload): Vec<string>{
    const errors: Vec<string> = [];
    if (isInvalidString(payload.location)){
        errors.push(`Location must not be empty. Current location='${payload.location}'.`)
    }
    if (isInvalidString(payload.uniqueIdentifier)){
        errors.push(`Unique Identifier must not be empty. Current uniqueIdentifier='${payload.uniqueIdentifier}'.`)
    }
    return errors;
}
// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
    const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
    return regexExp.test(id);
}

function isCallerOwner(land: Land): boolean {
    return land.owner.toString() === ic.caller().toString()
}

// Query to get all lands
$query
export function getLands(): Result<Vec<Land>, string> {
    return Result.Ok(landStorage.values());
}


// Query to get a specific land
$query
export function getLand(landId: string): Result<Land, string> {
    if (!isValidUuid(landId)) {
        return Result.Err(`landId=${landId} is not in the valid uuid format.`);
    }
    return match(landStorage.get(landId), {
        Some: (land) => Result.Ok<Land,string>(land),
        None: () => Result.Err<Land, string>(`Land with id=${landId} not found`),
    });
}

// Query to get all transactions
$query
export function getTransactions(): Result<Vec<Transaction>, string> {
    return Result.Ok(transactionStorage.values());
}

// Update to add a new land
$update
export function addLand(payload: LandPayload): Result<Land, string> {
    let payloadErrors = validateLandPayload(payload);
    if (payloadErrors.length) {
        return Result.Err(`Invalid payload. Errors=[${payloadErrors}]`);
    }
    const land: Land = { landId: uuidv4(), owner: ic.caller(), createdAt: ic.time(), updatedAt: Opt.None, ...payload };
    landStorage.insert(land.landId, land);
    return Result.Ok(land);
}

// Update to update an existing land
$update
export function updateLand(landId: string, payload: LandPayload): Result<Land, string> {
    if (!isValidUuid(landId)) {
        return Result.Err(`landId=${landId} is not in the valid uuid format.`);
    }
    let payloadErrors = validateLandPayload(payload);
    if (payloadErrors.length) {
        return Result.Err(`Invalid payload. Errors=[${payloadErrors}]`);
    }
    return match(landStorage.get(landId), {
        Some: (land) => {
            if (!isCallerOwner(land)){
                return Result.Err<Land, string>("Caller isn't the land's owner")
            }
            const updatedLand: Land = { ...land, ...payload, updatedAt: Opt.Some(ic.time()) };
            landStorage.insert(land.landId, updatedLand);
            return Result.Ok<Land, string>(updatedLand);
        },
        None: () => Result.Err<Land, string>(`Couldn't update land with id=${landId}. Land not found`),
    });
}

// Update to delete a land
$update
export function deleteLand(landId: string): Result<Land, string> {
    if (!isValidUuid(landId)) {
        return Result.Err(`landId=${landId} is not in the valid uuid format.`);
    }
    return match(landStorage.get(landId), {
        Some: (land) => {
            if (!isCallerOwner(land)){
                return Result.Err<Land, string>("Caller isn't the land's owner")
            }
            landStorage.remove(landId)
            return Result.Ok<Land, string>(land)
        },
        None: () => Result.Err<Land, string>(`Couldn't delete land with id=${landId}. Land not found.`),
    });
}

// Update to transfer a land to a new owner
$update
export function transferLand(landId: string, toOwner: Principal): Result<Land, string> {
    if (!isValidUuid(landId)) {
        return Result.Err(`landId=${landId} is not in the valid uuid format.`);
    }
    return match(landStorage.get(landId), {
        Some: (land) => {
            if (!isCallerOwner(land)){
                return Result.Err<Land, string>("Caller isn't the land's owner")
            }
            const transaction: Transaction = {
                transactionId: uuidv4(),
                landId,
                fromOwner: land.owner,
                toOwner,
                createdAt: ic.time(),
            };

            const updatedLand: Land = { ...land, owner: toOwner, updatedAt: Opt.Some(ic.time()) };

            landStorage.insert(land.landId, updatedLand);
            transactionStorage.insert(transaction.transactionId, transaction);

            return Result.Ok<Land, string>(updatedLand);
        },
        None: () => Result.Err<Land, string>(`Couldn't transfer land with id=${landId}. Land not found`),
    });
}
// Export an object with all functions as properties
export const LandModule = {
    getLands,
    getLand,
    getTransactions,
    addLand,
    updateLand,
    deleteLand,
    transferLand,
};

export default CanisterMethods;
// Workaround to make uuid package work with Azle
globalThis.crypto = {
    getRandomValues: () => {
        let array = new Uint8Array(32);

        for (let i = 0; i < array.length; i++) {
            array[i] = Math.floor(Math.random() * 256);
        }

        return array;
    },
};